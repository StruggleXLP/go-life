# Redis
- 数据结构
    - String
    - Hash
    - List
    - Set
    - Sorted Set
- 与其它Key-Value缓存产品对比：
    - Redis支持持久化，内存到磁盘；
    - 多种数据结构存储；
    - master-slave模式的数据备份
- 优势
    - 读速度：110000次/秒，写速度：81000次/秒
    - 支持string,hash,list,set,zset存储
    - 单个操作是原子性的
    - 多个操作也支持事务，通过MULTI和EXEC指令包起来
    - 支持publish/subscribe,通知，key过期等特性
- 配置
    - redis.conf文件
    - $CONFIG GET *
    - $CONFIG SET key value
    - [配置参数说明](https://www.runoob.com/redis/redis-conf.html)
- 数据类型
    - string类型的值最大能存储512MB
    - 每个hash可以存储 2的32次方 - 1键值对（40多亿）
    - 列表最多可存储 2的32次方 - 1元素 (4294967295, 每个列表可存储40多亿)
    - 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)
    - 集合中最大的成员数为 2的32次方 - 1(4294967295, 每个集合可存储40多亿个成员)
    - zset分数为double类型
- 命令
    - redis-cli --raw 防止中文乱码
- 注意
    - 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。
    - WATCH key[key...]
        - 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。
    - EVAL 执行lua脚本
    - QUIT 关闭当前链接
    - redis性能测试：redis-benchmark [option] [option value]
    - Redis管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应
    - Redis分区的利弊