# 数据结构

## 数组

```go
var arr = [10]int{1, 2, 3}
var arr2 = [...]int{1, 2, 3}
```

Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。

[...]T 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。

在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。

无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。

对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法 runtime.panicIndex 调用防止发生越界错误。

## 切片

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

切片初始化的方式：

1. 通过下标的方式获得数组或者切片的一部分；
    - 使用下标初始化切片不会拷贝原始数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体。

2. 使用字面量初始化新的切片；
    - 使用字面量 []int{1, 2, 3} 创建新的切片时，cmd/compile/internal/gc.slicelit 函数会在编译期间将它展开成如下所示的代码片段：
    ```go
        var vstat [3]int
        vstat[0] = 1
        vstat[1] = 2
        vstat[2] = 3
        var vauto *[3]int = new([3]int)
        *vauto = vstat
        slice := vauto[:]
    ```
   1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；
   2. 将这些字面量元素存储到初始化的数组中；
   3. 创建一个同样指向 [3]int 类型的数组指针；
   4. 将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址；
   5. 通过 [:] 操作获取一个底层使用 vauto 的切片；
   - 第 5 步中的 [:] 就是使用下标创建切片的方法，从这一点我们也能看出 [:] 操作是创建切片最底层的一种方法。
3. 使用关键字make创建切片；

